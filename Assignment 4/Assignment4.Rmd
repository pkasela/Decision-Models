---
title: "Assignment 4"
author: "Pranav Kasela $846965$"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.align = 'center')
```

```{r packages, message=F}
require(curry)
require(GA)
require(ggplot2)
require(reshape2)
require(dplyr)
require(Rcpp)
```

## Function definition

Initially the function that were being using were the written in R, but one of our colleague Federico Moiraghi, was kind enough to provide his code compiled in Cpp for the time function to speed up the process. Some parameters are modified in the function before reusing his code.

```{r Slow Time function}
time <- function(perm,distMatrix){
  n_jobs     <- ncol(distMatrix)
  n_machines <- nrow(distMatrix)
  dist       <- matrix(NA, nrow=n_machines, ncol=n_jobs)
  dist[1,]   <- cumsum(distMatrix[1,perm])
  dist[,1]   <- cumsum(distMatrix[,perm[1]])
  for (i in 2:n_machines){
    for (j in 2:n_jobs){
      dist[i,j] <- distMatrix[i,perm[j]] + 
        max(dist[i,j-1],dist[i-1,j])
    }
  }
  makespan   <- dist[n_machines,n_jobs]
  return(makespan)
}

fitness <- function(perm,distMatrix){
  return(1/time(perm,distMatrix))
}
```

From hereon the time function used will be timeCpp, while the fitness code will be fitnessCpp.

```{r Cpp function}
cppFunction('double fitnessCpp(NumericVector perm,
                            NumericMatrix distMatrix)
    {
        int nrow = distMatrix.nrow();
        int ncol = distMatrix.ncol();
        int norder = perm.size();
        NumericVector order(norder);
        for (int i = 0; i < norder; i++) order[i] = perm[i]-1;
        NumericMatrix time_matrix(nrow, norder);
        time_matrix[0] = distMatrix[nrow * order[0]];
        for (int r = 1; r < nrow; r++)
            time_matrix[r] = time_matrix[r - 1] +
            distMatrix[nrow * order[0] + r];
        for (int c = 1; c < norder; c++)
            time_matrix[nrow * c] = time_matrix[nrow * (c - 1)] +
            distMatrix[nrow * order[c]];
        for (int r = 1; r < nrow; r++)
            for (int c = 1; c < norder; c++)
                if (time_matrix[nrow * c + (r - 1)] > time_matrix[nrow * (c - 1) + r])
                    time_matrix[nrow * c + r] = time_matrix[nrow * c + (r - 1)] +
            distMatrix[nrow * order[c] + r];
        else
            time_matrix[nrow * c + r] = time_matrix[nrow * (c - 1) + r] +
            distMatrix[nrow * order[c] + r];
        return 1/time_matrix[nrow * norder - 1];
    }')

cppFunction('double timeCpp(NumericVector perm,
                            NumericMatrix distMatrix)
    {
        int nrow = distMatrix.nrow();
        int ncol = distMatrix.ncol();
        int norder = perm.size();
        NumericVector order(norder);
        for (int i = 0; i < norder; i++) order[i] = perm[i]-1;
        NumericMatrix time_matrix(nrow, norder);
        time_matrix[0] = distMatrix[nrow * order[0]];
        for (int r = 1; r < nrow; r++)
            time_matrix[r] = time_matrix[r - 1] +
            distMatrix[nrow * order[0] + r];
        for (int c = 1; c < norder; c++)
            time_matrix[nrow * c] = time_matrix[nrow * (c - 1)] +
            distMatrix[nrow * order[c]];
        for (int r = 1; r < nrow; r++)
            for (int c = 1; c < norder; c++)
                if (time_matrix[nrow * c + (r - 1)] > time_matrix[nrow * (c - 1) + r])
                    time_matrix[nrow * c + r] = time_matrix[nrow * c + (r - 1)] +
            distMatrix[nrow * order[c] + r];
        else
            time_matrix[nrow * c + r] = time_matrix[nrow * (c - 1) + r] +
            distMatrix[nrow * order[c] + r];
        return time_matrix[nrow * norder - 1];
    }')
```

## Table with 20 jobs for 5 machines for the performance checking

Here the testing of the functions are done with the smallest table. The algorithm used are the Genetic Algorithm and the Simulated Annealing to check their performance.
### GA algorithm

```{r ga with 20-5}
#This is the pretest given in the assignment
time_matrix <- matrix(c(29,30,27,2,37,62,21,6,95,59,70,82,
                 85,11,62,80,65,55,67,57),nrow = 4)

time_matrix <- as.matrix(read.csv("j20-m5",sep=" ",header = FALSE))
n_jobs <- ncol(time_matrix)


time_taken <- microbenchmark::microbenchmark(
  GA.fit <- ga(type = "permutation",
    fitness = fitnessCpp,
    distMatrix = time_matrix,
    lower = 1,
    upper = n_jobs,
    popSize = 600, 
    maxiter = 10000,
    run = 200,
    pmutation = 0.2,
    keepBest = TRUE,
    monitor = NULL,
    seed = 1234),
times = 1
)

summary(GA.fit)

timeCpp(GA.fit@solution[1,],time_matrix) #best time
```
```{r no output plot, fig.show='hide'}
out <- plot(GA.fit, main = "GA progression")
```
```{r plot}
melt(out[,c(1:3,5)],id.var="iter") %>% 
  mutate(time=1/value) -> df1

ggplot(df1, aes(x = iter, y = time, 
               group = variable, colour = variable)) +
  xlab("Generation") + ylab("Time values") +
  #geom_point(aes(shape = variable)) +
  geom_line(aes(lty = variable)) +
  scale_colour_brewer(palette = "Set1") +
  theme_bw() +
  labs(title = "GA Progression")
```

### SA algorithm

```{r SA}
swapJobs <- function(perm){
    perm <- as.numeric(perm)
    n <- length(perm)
    n_change <- min(sample(1:floor(n/2),1),5) #no more than 5 changes at a time
    change <- sort(sample.int(n,n_change))
    newperm <- replace(perm,change,perm[sort(change,decreasing = TRUE)])
    return(as.numeric(newperm))
}

SA <- function(tour, distMatrix, maxIterNoChange = 2000, T_ini = 50, T_min = 1){
  path <- tour
  n <- length(path)
  tmin <- T_min    # minimum temperature
  alpha <- 0.999  # update factor
  T <- T_ini
  tini <- T_ini   # starting temperature
  dist <- timeCpp(path, distMatrix)
  bestLength <- dist
  traceBest <- c(dist) 
  traceCurrentLength <- c(dist)
  iterNoChange = 0
  while(T >= tmin){        # if the temperature is not at its minimum
    iterNoChange = iterNoChange+1
    newpath <- swapJobs(path) #swap
    dist_new <- timeCpp(newpath, distMatrix)
    if(dist_new <= bestLength){
      path <- newpath
      dist <- dist_new
      bestLength <- dist
      iterNoChange <- 0
    }
    else {
      
      if (exp((dist-dist_new)/T)>runif(1, 0, 1)){
        dist <- dist_new
        path <- newpath
        iterNoChange <- 0
      }
      
    }
    traceBest <- append(traceBest, bestLength)
    traceCurrentLength <- append(traceCurrentLength, dist)
    T <- T*alpha # the temperature is updated
    if(iterNoChange >= maxIterNoChange){ break}
  }
  res = list(route=path, traceBest = traceBest, trace = traceCurrentLength)
  class(res) = "SAObj"
  print(paste("best=", toString(bestLength), sep=" "))
  return(res)  
}

start <- as.numeric(sample(1:n_jobs,n_jobs)) #start randomly
res <- SA(start, time_matrix, maxIterNoChange = 10000)
```

When trying with the 100x20 table, the **GA** algorithm finished in approximately 15 minutes, while **SA** algorithm finished in a few seconds giving more or less the same result so the best choice was to procceed using only the **SA** algorithm.  The result for the 100x20 table is not provided here in order to avoid waiting 15 minutes more every compilation of the results.

## Final Results using 500 jobs with 20 machines.

```{r final with 500x20}
time_matrix <- as.matrix(read.csv("j500-m20",sep=" ",header = FALSE))
n_jobs <- ncol(time_matrix)

funObj <- tail_curry(timeCpp,time_matrix)


start <- as.numeric(sample(1:n_jobs,n_jobs))

res <- SA(start,time_matrix,maxIterNoChange = 100,T_ini = 10000,T_min = 1)

ggplot(data = data.frame(iteration=1:length(res$traceBest),
                         optimal=res$traceBest), aes(iteration,optimal)) + 
  geom_line()
```

```{r}
cppFunction('double timeCppMatrix(NumericVector perm,
                            NumericMatrix distMatrix)
    {
        int nrow = distMatrix.nrow();
        int ncol = distMatrix.ncol();
        int norder = perm.size();
        NumericVector order(norder);
        for (int i = 0; i < norder; i++) order[i] = perm[i]-1;
        NumericMatrix time_matrix(nrow, norder);
        time_matrix[0] = distMatrix[nrow * order[0]];
        for (int r = 1; r < nrow; r++)
            time_matrix[r] = time_matrix[r - 1] +
            distMatrix[nrow * order[0] + r];
        for (int c = 1; c < norder; c++)
            time_matrix[nrow * c] = time_matrix[nrow * (c - 1)] +
            distMatrix[nrow * order[c]];
        for (int r = 1; r < nrow; r++)
            for (int c = 1; c < norder; c++)
                if (time_matrix[nrow * c + (r - 1)] > time_matrix[nrow * (c - 1) + r])
                    time_matrix[nrow * c + r] = time_matrix[nrow * c + (r - 1)] +
            distMatrix[nrow * order[c] + r];
        else
            time_matrix[nrow * c + r] = time_matrix[nrow * (c - 1) + r] +
            distMatrix[nrow * order[c] + r];
        return time_matrix;
    }')
```

## For the Extra point, NEH algorithm for the suboptimal solution

```{r NEH}
NEH <- function(distMatrix,fun.obj,REPORT=0){
  sum <- rbind(colSums(distMatrix),1:ncol(distMatrix)) 
  sum_order <- sum[,order(sum[1,])]
  
  temp_job <- rbind(cbind(sum_order[2,1],sum_order[2,2]),
                    cbind(sum_order[2,2],sum_order[2,1]))
  
  if(fun.obj(1:ncol(temp_job),distMatrix[,temp_job[1,]])>
           fun.obj(1:ncol(temp_job),distMatrix[,temp_job[2,]]))
    job <- temp_job[2,] else
    job <- temp_job[1,]
  
  for (i in 3:ncol(distMatrix)){
    #create possible position for the new job
    temp_job <- rbind(c(job,sum_order[2,i]),
                      c(sum_order[2,i],job))
    for (j in 1:(length(job)-1)){
      temp_job<-rbind(temp_job,
                      c(job[1:j],sum_order[2,i],job[(j+1):length(job)]))
    }
    t <- sapply(1:nrow(temp_job),function(x) {
      fun.obj(1:ncol(temp_job),distMatrix[,temp_job[x,]])
    } )
    job <- as.numeric(temp_job[which.min(t),])
    if(REPORT!=0 && i%%REPORT==0)
      print(paste0("Done ",as.character(i)," jobs"))
  }
  return(list(sol   = job,
              value = fun.obj(job,distMatrix) ))
}
```

```{r}
time_taken <- microbenchmark::microbenchmark(
ris <- NEH(distMatrix = time_matrix, fun.obj = timeCpp,REPORT=100),times = 1
)

ris$value
```


